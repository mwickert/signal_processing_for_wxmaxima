/* Useful Digital Signal Processing Functions for wxmaxima

MIT License

Copyright (c) 2025 Mark Wickert

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */


load("fft");
load("distrib");


ones(N):= block([x_ones],
	x_ones:makelist(1,n,1,N)
);


zeros(N):= block([x_zeros],
	x_zeros:makelist(0,n,1,N)
);


dstep(n,n_shift):= block([N,y_step],
    N:length(n),
    y_step:makelist(if n[k] < n_shift then 0
                    else 1,k,1,N)
);


drect(n,n_shift,M_len):= block([N,n_start,n_stop,y_rect],
    N:length(n),
    n_start:n_shift,
    n_stop:n_shift+M_len,
    y_rect:makelist(if n[k] < n_shift then 0
                    elseif n[k] < n_stop then 1
                    else 0,k,1,N)
);


downsample(x,M_dn,p_phase):= block([Nx,Ny,y_dn],
    if p_phase = [] then p_phase:0, /* take first sample */
    Nx:length(x),
    Ny:floor((Nx-p_phase+1)/M_dn),
    print(Ny),
    /* For convenience is code using this function handle M_dn=1*/
    if M_dn = 1 then y_dn:x
    else y_dn:makelist(x[M_dn*(k-1)+p_phase+1],k,1,Ny)
);


upsample(x,L_up):= block([N,y_up],
    N:length(x),
    y_up:makelist(if mod(k-1,L_up) = 0 then x[floor(k/L_up)+1]
                  else 0,k,1,L_up*N)
);


zplane(b_coef,a_coef,ri_minmax):= block([minr,maxr,mini,maxi],
    cpxzeros:allroots(sum(reverse(float(b_coef))[k]*x^(k-1),k,1,length(b_coef))),
    cplxzeros:makelist(rhs(cpxzeros[k]),k,1,length(cpxzeros)),
    rizeros:makelist([realpart(rhs(cpxzeros[k])),imagpart(rhs(cpxzeros[k]))],k,1,length(cpxzeros)),
    cpxpoles:allroots(sum(reverse(float(a_coef))[k]*x^(k-1),k,1,length(a_coef))),
    cplxpoles:makelist(rhs(cpxpoles[k]),k,1,length(cpxpoles)),
    ripoles:makelist([realpart(rhs(cpxpoles[k])),imagpart(rhs(cpxpoles[k]))],k,1,length(cpxpoles)),
    if length(cpxzeros) > length(cpxpoles) then ripoles:cons([0,%i*0],ripoles),
    if length(cpxzeros) < length(cpxpoles) then rizeros:cons([0, %i*0],rizeros),
    /* Do  plot scaling based on max and min of the  real and imaginary roots */
    minr:min(lmin(realpart(cplxzeros)),lmin(realpart(cplxpoles))),
    minr:min(floor(2*minr)/2,-3/2),
    maxr:max(lmax(realpart(cplxzeros)),lmax(realpart(cplxpoles))),
    maxr:max(ceiling(2*maxr)/2,3/2),
    mini:min(lmin(imagpart(cplxzeros)),lmin(imagpart(cplxpoles))),
    mini:min(floor(2*mini)/2,-3/2),
    maxi:max(lmax(imagpart(cplxzeros)),lmax(imagpart(cplxpoles))),
    maxi:max(ceiling(2*maxi)/2,3/2),
    if ri_minmax = [] then ri_minmax:[minr,maxr,mini,maxi],
    wxdraw2d(
    /* dashes, short_dashes, short_long_dashes, short_short_long_dashes, 
       and dot_dash */
    proportional_axes=xy,
    nticks = 60,
    line_type = dashes, color=red, line_width = 1,
    parametric(cos(t),sin(t),t,0,2*%pi),
    color=blue,point_type=circle,point_size=1.5,
    /*key="zeros",*/
    points(rizeros),
    color=green,point_type=2,point_size=1.5, /* 2 <=> x */
    /*key="poles",*/
    points(ripoles),
    grid=[1,1],
    xlabel = "Real",
    ylabel = "Imaginary",
    title = "Pole-Zero Plot",
    xrange=[ri_minmax[1],ri_minmax[2]],yrange=[ri_minmax[3],ri_minmax[4]]
   )
);


freqz(b_coef,a_coef,xlim,ylim,mode,title1,f_axis,fs):= block([],
    if mode = [] then mode:"ampl_dB",
    if f_axis = [] then f_axis:"Hz",
    if fs = [] then fs:1,
    if title1 = [] then title1:"DTFT of a Signal or Rational System Function",
    if f_axis = "rad/samp" then 
    (
        if xlim = [] then xlim:[0,%pi],
        /*if ylim = [] then ylim:[-60,1],*/
        Bw(ω):=sum(b_coef[k]*%e^(-%i*ω*(k-1)),k,1,length(b_coef)),
        Aw(ω):=sum(a_coef[k]*%e^(-%i*ω*(k-1)),k,1,length(a_coef)),
        if sequal(mode,"ampl_dB") then
            wxdraw2d(
                explicit(20*log(cabs(Bw(ω)/Aw(ω)))/log(10),ω,xlim[1],xlim[2]),
                grid=[1,1],
                if ylim = [] then yrange=auto
                else yrange=[ylim[1],ylim[2]],
                xlabel="Frequency ω (rad/samp)",
                ylabel="Gain (dB)",
                title=title1
            ) 
        elseif sequal(mode,"ampl") then
            wxdraw2d(
                explicit(cabs(Bw(ω)/Aw(ω)),ω,xlim[1],xlim[2]),
                grid=[1,1],
                if ylim = [] then yrange=auto
                else yrange=[ylim[1],ylim[2]],
                xlabel="Frequency ω (rad/samp)",
                ylabel="Gain",
                title=title1
            ) 
        else 
            wxdraw2d(
                explicit(carg(Bw(ω)/Aw(ω)),ω,xlim[1],xlim[2]),
                grid=[1,1],
                if ylim = [] then yrange=auto
                else yrange=[ylim[1],ylim[2]],
                xlabel="Frequency ω (rad/samp)",
                ylabel="Phase (rad)", 
                title=title1
            ) 
    )
    else 
    (
        if xlim = [] then xlim:[0,fs/2],
        /*if ylim = [] then ylim:[-60,1], */  
        Bw(f):=sum(b_coef[k]*%e^(-%i*2*%pi*f*(k-1)/fs),k,1,length(b_coef)),
        Aw(f):=sum(a_coef[k]*%e^(-%i*2*%pi*f*(k-1)/fs),k,1,length(a_coef)),
        if sequal(mode,"ampl_dB") then
            wxdraw2d(
                explicit(20*log(cabs(Bw(f)/Aw(f)))/log(10),f,xlim[1],xlim[2]),
                grid=[1,1],
                if ylim = [] then yrange=auto
                else yrange=[ylim[1],ylim[2]],
                xlabel="Frequency (Hz)",
                ylabel="Gain (dB)",
                title=title1
            )
        elseif sequal(mode,"ampl") then
            wxdraw2d(
                explicit(cabs(Bw(f)/Aw(f)),f,xlim[1],xlim[2]),
                grid=[1,1],
                if ylim = [] then yrange=auto
                else yrange=[ylim[1],ylim[2]],
                xlabel="Frequency (Hz)",
                ylabel="Gain",
                title=title1
            )
        else
            wxdraw2d( 
                explicit(carg(Bw(f)/Aw(f)),f,xlim[1],xlim[2]),
                grid=[1,1],
                if ylim = [] then yrange=auto
                else yrange=[ylim[1],ylim[2]],
                xlabel="Frequency (Hz)",
                ylabel="Phase (rad)",
                title=title1
            ) 
    )
);


rotate(e, n):=
   if atom(e) then e
   else append (rest (e, length(e) - n), rest (e, -n));


fir_filt(b_coef,x):= block([x_wrk,y_wrk],
    M:length(b_coef),
    Nx:length(x),
    x_wrk:makelist(0,i,1,M),
    y_wrk:[],
    for n:1 thru Nx step 1 do
    (
        x_wrk:rotate(x_wrk,1),
        pop(x_wrk), /* not used */
        push(x[n],x_wrk),
        push(sum(x_wrk[k]*b_coef[k],k,1,M),y_wrk) 
    ),
    reverse(y_wrk)
);


filt(b_coef,a_coef,x,y_ic,x_ic):= block([x_wrk,y_wrk,y_out],
    M:length(b_coef),
    N:length(a_coef),
    if y_ic = [] then y_wrk:makelist(0,i,1,N)
    else y_wrk:makelist(if k < N then y_ic[k]
                        else 0,k,1,N),
    if x_ic = [] then x_wrk:makelist(0,i,1,M)
    else x_wrk:makelist(if k < M then x_ic[k]
                        else 0,k,1,M),
    Nx:length(x),
    y_out:[],
    for n:1 thru Nx step 1 do
    (
        x_wrk:rotate(x_wrk,1), /* right shift */
        pop(x_wrk), /* remove old value that rotates to front */
        push(x[n],x_wrk), /* newest value at front */
        /* Direct form 1 difference equation*/
        y_new:sum(x_wrk[k]*b_coef[k],k,1,M)-sum(y_wrk[j]*a_coef[j+1],j,1,N-1),
        push(y_new,y_out),
        /* update y_wrk */
        y_wrk:rotate(y_wrk,1),
        pop(y_wrk), /* remove old value that rotates to front */
        push(y_new,y_wrk) /* newest value at front */
    ),
    reverse(y_out)
);


listconv(x,y):= block([Nx,Ny,xy_pad,z],
    Nx:length(x),
    Ny:length(y),
    Nz:Nx + Ny - 1,
    /* zero pad the longer sequence to length Nx+Ny - 1 */
    if Nx >= Ny then
    (
        xy_pad:append(x,makelist(0,n,1,Nz-Nx)),
        z:fir_filt(y,xy_pad)
    )
    else
    (
        xy_pad:append(y,makelist(0,n,1,Nz-Ny)),
        z:fir_filt(x,xy_pad)
    )
);


/* FFT/IFFT using power of two transforms as found in DSP texts and literature */
fft_dsp(x,Np2):= block([x_Np2], /* must have a power of two length */
    if Np2 = [] then (
        Np2 = length(x),
        x_Np2:x
    )
    elseif Np2 > length(x) then x_Np2:append(x,makelist(0,n,1,Np2-length(x)))
    else x_Np2:firstn(x,Np2),
    inverse_fft(x_Np2)
);


ifft_dsp(X):= fft(X); /* must have a power of two length */


DFT_pt(x,k):=block([N],
    N:length(x),
    sum(x[n]*exp(-%i*2*%pi*(n-1)*k/N),n,1,N)
);


DFT(x):=block(
    N:length(x),
    makelist(DFT_pt(x,k),k,0,N-1)
);


IDFT_pt(X,n):= block([N],
    N:length(X),
   1/N * sum(X[k]*exp(%i*2*%pi*(k-1)*n/N),k,1,N)
);


IDFT(X):=block(
    N:length(X),
    makelist(IDFT_pt(X,n),n,0,N-1)
);


stemlist(y_data,x_label,y_label,title1,ylim,first_x_value):= block([ylim_auto],
    if x_label = [] then x_label:"Index n",
    if y_label = [] then y_label:"Amplitude",
    if title1 = [] then title1:"Discrete-Time Plot",
    if first_x_value = [] then first_x_value:0,
    xy_data:makelist([n-1+first_x_value,y_data[n]],n,1,length(y_data)),      
    wxdraw2d(
        grid=true,
        title=title1,
        points_joined = impulses,
        line_width = 2, color = blue,
        points(xy_data),
        points_joined=false,point_size=1,color=blue,point_type=filled_circle,
        points(xy_data),
        grid=[1,1],
        if ylim = [] then yrange=auto
        else yrange=[ylim[1],ylim[2]],
        xlabel=x_label,
        ylabel=y_label
    )
);


plotlist(y_data,x_label,y_label,title1,ylim,first_x_value):= block([],
    if x_label = [] then x_label:"Index n",
    if y_label = [] then y_label:"Amplitude",
    if title1 = [] then title1:"Discrete-Time Plot",
    if first_x_value = [] then first_x_value:0,
    xy_data:makelist([n-1+first_x_value,y_data[n]],n,1,length(y_data)) ,      
    wxdraw2d(
        grid=true,
        title=title1,
        points_joined=true,point_size=0.01,color=blue,point_type=none,
        points(xy_data),
        grid=[1,1],
        if ylim = [] then yrange=auto
        else yrange=[ylim[1],ylim[2]],
        xlabel=x_label,
        ylabel=y_label
    )
);


plotlist2(y_data1,y_data2,x_label,y_label,title1,ylim,first_x_value):= block([],
    if x_label = [] then x_label:"Index n",
    if y_label = [] then y_label:"Amplitude",
    if title1 = [] then title1:"Discrete-Time Plot",
    if first_x_value[1] = [] then first_x_value[1]:0,
    if first_x_value[2] = [] then first_x_value[2]:0,
    xy_data1:makelist([n-1+first_x_value[1],y_data1[n]],n,1,length(y_data1)) ,
    xy_data2:makelist([n-1+first_x_value[2],y_data2[n]],n,1,length(y_data2)),
    wxdraw2d(
        grid=true,
        title=title1,
        points_joined=true,point_size=0.01,color=blue,point_type=none,
        points(xy_data1),
        points_joined=true,point_size=0.01,color=green,point_type=none,
        points(xy_data2),
        grid=[1,1],
        if ylim = [] then yrange=auto
        else yrange=[ylim[1],ylim[2]],
        xlabel=x_label,
        ylabel=y_label
    )
);


plotlist3(y_data1,y_data2,y_data3,x_label,y_label,title1,ylim,first_x_value):= block([],
    if x_label = [] then x_label:"Index n",
    if y_label = [] then y_label:"Amplitude",
    if title1 = [] then title1:"Discrete-Time Plot",
    if first_x_value[1] = [] then first_x_value[1]:0,
    if first_x_value[2] = [] then first_x_value[2]:0,
    if first_x_value[3] = [] then first_x_value[3]:0,
    xy_data1:makelist([n-1+first_x_value[1],y_data1[n]],n,1,length(y_data1)) ,
    xy_data2:makelist([n-1+first_x_value[2],y_data2[n]],n,1,length(y_data2)),
    xy_data3:makelist([n-1+first_x_value[3],y_data3[n]],n,1,length(y_data3)),
    wxdraw2d(
        grid=true,
        title=title1,
        points_joined=true,point_size=0.01,color=blue,point_type=none,
        points(xy_data1),
        points_joined=true,point_size=0.01,color=green,point_type=none,
        points(xy_data2),
        points_joined=true,point_size=0.01,color=red,point_type=none,
        points(xy_data3),
        grid=[1,1],
        if ylim = [] then yrange=auto
        else yrange=[ylim[1],ylim[2]],
        xlabel=x_label,
        ylabel=y_label
    )
);


plotlist4(y_data1,y_data2,y_data3,y_data4,x_label,y_label,title1,ylim,first_x_value):= block([],
    if x_label = [] then x_label:"Index n",
    if y_label = [] then y_label:"Amplitude",
    if title1 = [] then title1:"Discrete-Time Plot",
    if first_x_value[1] = [] then first_x_value[1]:0,
    if first_x_value[2] = [] then first_x_value[2]:0,
    if first_x_value[3] = [] then first_x_value[3]:0,
    if first_x_value[4] = [] then first_x_value[4]:0,
    xy_data1:makelist([n-1+first_x_value[1],y_data1[n]],n,1,length(y_data1)) ,
    xy_data2:makelist([n-1+first_x_value[2],y_data2[n]],n,1,length(y_data2)),
    xy_data3:makelist([n-1+first_x_value[3],y_data3[n]],n,1,length(y_data3)),
    xy_data4:makelist([n-1+first_x_value[4],y_data4[n]],n,1,length(y_data4)),
    wxdraw2d(
        grid=true,
        title=title1,
        points_joined=true,point_size=0.01,color=blue,point_type=filled_circle,
        points(xy_data1),
        points_joined=true,point_size=0.01,color=green,point_type=filled_circle,
        points(xy_data2),
        points_joined=true,point_size=0.01,color=red,point_type=filled_circle,
        points(xy_data3),
        points_joined=true,point_size=0.01,color=black,point_type=filled_circle,
        points(xy_data4),
        grid=[1,1],
        if ylim = [] then yrange=auto
        else yrange=[ylim[1],ylim[2]],
        xlabel=x_label,
        ylabel=y_label
    )
);


log10(x,float_mode):= block([x_log10],
    if float_mode = [] then float_mode:true,
    if float_mode then (
        x_log10:float(log(x)/log(10))
    )
    else (
        x_log10:log(x)/log(10)
    )
);

sinc(x):= if x = 0 then 1 else sin(%pi*x)/(%pi*x);


hann(L):=makelist((1/2*(1 - cos(2*%pi*n/(L-1)))),n,0,L-1);


psd(x,N_fft,fs,ylim,x_label,y_label,title1,real_signal,overlap_percent,scale_noise):= 
    block([Q,w,U,U2,Px,f,i,K,x_rec,X_rec,Px_nf,xy_data],
    if x_label = [] then x_label:"Frequency (Hz)",
    if y_label = [] then y_label:"Power Spectral Density (dB/Hz)",
    if title1 = [] then title1:"Power Spectral Density Plot",
    if real_signal = [] then real_signal:true,
    if overlap_percent = [] then overlap_percent:50,
    if scale_noise = [] then scale_noise:true,
    Q:length(x),
    R:floor(overlap_percent/100*N_fft),
    w:float(hann(N_fft)),
    U:sum((w^2)[k],k,1,N_fft)/N_fft, /* for proper noise gain scaling with window */
    U2:sum(w[k],k,1,N_fft)/N_fft, /* for proper sinusoid gain scaling with window */
    if real_signal then (
        Px:makelist(0,k,1,N_fft/2+1),
        f:makelist(fs*(k-1)/N_fft,k,1,N_fft/2+1)
    )
    else (
        Px:makelist(0,k,1,N_fft),
        f:makelist(fs*(k-N_fft/2-1)/N_fft,k,1,N_fft)
    ),
    i:0,
    while i*(N_fft-R)+1+N_fft <= Q do ( 
        i_start:i*(N_fft-R)+1,
        x_rec:makelist(x[i_start+k-1],k,1,N_fft),
        x_rec: x_rec*w,
        X_rec:inverse_fft(x_rec),
        if real_signal then (
            Px:Px + makelist(cabs(X_rec[k])^2,k,1,N_fft/2+1)
        )
        else (
            Px_nf: makelist(cabs(X_rec[k+N_fft/2])^2,k,1,N_fft/2),
            Px:Px + append(Px_nf,makelist(cabs(X_rec[k])^2,k,1,N_fft/2))
        ),
        i:i + 1
    ),
    K:i, /* number of periodograms (|X(e^{jw_k})|^2) averaged */
    /* PSD in Watts/Hz for a 1 ohm system when multiplied by sample spacing T
       for continuous spectrum noise-like signals, for sinusoids need to rescale */
    if scale_noise then (
        Px: Px/(K*U*N_fft)
    )
    else (
        /* For continuous spectrum noise-like signals, for sinusoids need to rescale */
        Px: Px/(K*N_fft^2*U2^2)
    ),

    xy_data:makelist([f[n],10*log(Px[n])/log(10)],n,1,length(f)),
    wxdraw2d(
        grid=true,
        title=title1,
        points_joined=true,point_size=0.01,color=blue,point_type=none,
        points(xy_data),
        grid=[1,1],
        if ylim = [] then yrange=auto
        else yrange=[ylim[1],ylim[2]],
        xlabel=x_label,
        ylabel=y_label
    )
)$
    
/* End of DSPTools.mac */